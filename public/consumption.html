<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DG Consumption Details</title>
<link rel="icon" type="image/png" href="/logo.png">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<style>
  :root {
    --primary: #0052cc; --success: #00875a; --warning: #ffab00; --danger: #de350b;
    --bg-primary: #ffffff; --bg-secondary: #f4f5f7; --bg-tertiary: #ffffff;
    --text-primary: #172b4d; --text-secondary: #42526e; --text-muted: #6b778c;
    --border: #dfe1e6;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: var(--bg-primary); font-family: 'Segoe UI', Tahoma, sans-serif; color: var(--text-primary); min-height: 100vh; padding: 15px; }
  .container { max-width: 1600px; margin: 0 auto; }
  .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 20px; background: var(--bg-secondary); border-radius: 12px; border: 1px solid var(--border); flex-wrap: wrap; gap: 15px; }
  .header-left h1 { font-size: 1.8rem; background: linear-gradient(90deg, #0052cc, #0065ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 5px; }
  .header-left .subtitle { font-size: 0.9rem; color: var(--text-muted); }
  .header-right { display: flex; gap: 10px; flex-wrap: wrap; }
  .btn { padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; font-weight: 600; transition: all 0.3s; text-decoration: none; display: inline-block; font-size: 0.95rem; }
  .btn-primary { background: var(--primary); color: white; }
  .btn-success { background: var(--success); color: white; }
  .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); }
  .filters { background: var(--bg-secondary); border: 1px solid var(--border); padding: 20px; border-radius: 12px; margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
  .filter-group { display: flex; flex-direction: column; gap: 8px; }
  label { font-size: 0.9rem; color: var(--text-muted); font-weight: 600; }
  input, select { padding: 10px; border-radius: 6px; border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary); font-size: 0.95rem; }
  .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 25px; }
  .stat-card { background: var(--bg-tertiary); border: 1px solid var(--border); padding: 20px; border-radius: 12px; text-align: center; border-top: 4px solid var(--primary); }
  .stat-label { font-size: 0.85rem; color: var(--text-muted); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-value { font-size: 2.2rem; font-weight: 800; margin-bottom: 5px; color: var(--text-primary); }
  .stat-unit { font-size: 0.85rem; color: var(--text-muted); }
  
  #refill-details { 
    margin-top: 10px; font-size: 0.75rem; color: var(--text-muted); text-align: left;
    max-height: 80px; overflow-y: auto; padding: 5px; background: rgba(0, 82, 204, 0.05); border-radius: 4px;
  }
  
  .chart-section { background: var(--bg-secondary); border: 1px solid var(--border); padding: 25px; border-radius: 12px; margin-bottom: 20px; }
  .chart-title { font-size: 1.3rem; font-weight: 700; margin-bottom: 20px; color: var(--text-primary); border-left: 4px solid var(--primary); padding-left: 15px; }
  .chart-container { position: relative; height: 400px; }
  .loading, .empty-state { text-align: center; padding: 60px; color: var(--text-muted); font-size: 1.2rem; }
  .empty-state { background: var(--bg-secondary); border-radius: 12px; }
  .empty-state-icon { font-size: 4rem; margin-bottom: 20px; opacity: 0.5; }

  @media (max-width: 768px) {
    .header { flex-direction: column; align-items: flex-start; }
    .header-right { width: 100%; flex-direction: column; }
    .btn { width: 100%; text-align: center; }
    .chart-container { height: 300px; }
  }
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1 id="page-title">DG Consumption Details</h1>
        <div class="subtitle" id="date-range">Loading...</div>
      </div>
      <div class="header-right">
        <button class="btn btn-success" onclick="exportAllData()">üì• Download All Data</button>
        <a href="/" class="btn btn-secondary">‚Üê Back to Dashboard</a>
      </div>
    </div>

    <div class="filters">
      <div class="filter-group">
        <label>From Date</label>
        <input type="date" id="start-date" />
      </div>
      <div class="filter-group">
        <label>To Date</label>
        <input type="date" id="end-date" />
      </div>
      <div class="filter-group">
        <label>Quick Select</label>
        <select id="quick-select">
          <option value="today" selected>Today</option>
          <option value="yesterday">Yesterday</option>
          <option value="week">Last 7 Days</option>
          <option value="month">Last 30 Days</option>
          <option value="custom">Custom Range</option>
        </select>
      </div>
      <div class="filter-group" style="justify-content: flex-end;">
        <label>&nbsp;</label>
        <button class="btn btn-primary" onclick="loadData()">Apply Filter</button>
      </div>
    </div>

    <div class="stats-grid">
      <div class="stat-card"><div class="stat-label">Start Level</div><div class="stat-value" id="start-level">--</div><div class="stat-unit">Liters</div></div>
      <div class="stat-card"><div class="stat-label">End Level</div><div class="stat-value" id="end-level">--</div><div class="stat-unit">Liters</div></div>
      <div class="stat-card" style="border-top-color: var(--danger);"><div class="stat-label">Total Consumption</div><div class="stat-value" id="total-consumption" style="color: var(--danger);">--</div><div class="stat-unit">Liters</div></div>
      
      <div class="stat-card" id="refill-info-card" style="border-top-color: #0052cc;">
        <div class="stat-label">‚õΩ Total Refilled</div>
        <div class="stat-value" id="total-refilled" style="color: #0052cc;">--</div>
        <div class="stat-unit">Liters</div>
        <div id="refill-details"></div>
      </div>
      
      <div class="stat-card" style="border-top-color: var(--success);"><div class="stat-label">Total Running Hours</div><div class="stat-value" id="running-hours" style="color: var(--success);">--</div><div class="stat-unit">Hours</div></div>
      <div class="stat-card" style="border-top-color: var(--warning);"><div class="stat-label">Avg Consumption</div><div class="stat-value" id="avg-consumption" style="color: var(--warning);">--</div><div class="stat-unit">L/Hour</div></div>
      <div class="stat-card" id="refill-card"><div class="stat-label">Refill Prediction</div><div class="stat-value" id="refill-prediction" style="color: var(--primary);">--</div><div class="stat-unit">Days until 50L</div></div>
    </div>

    <div class="chart-section">
      <div class="chart-title" id="consumption-chart-title">üìà Hourly Diesel Consumption</div>
      <div class="chart-container">
        <canvas id="consumptionChart"></canvas>
      </div>
    </div>

    <div class="chart-section">
      <div class="chart-title" id="level-chart-title">üìâ Diesel Level Over Time</div>
      <div class="chart-container">
        <canvas id="levelChart"></canvas>
      </div>
    </div>

    <div id="loading" class="loading" style="display:none;">‚è≥ Loading data...</div>
    <div id="empty-state" class="empty-state" style="display:none;">
      <div class="empty-state-icon">üì≠</div>
      <h2>No Data Available</h2>
      <p>No consumption data found for the selected date range.</p>
    </div>
  </div>

<script>
// consumption.html - FINAL: DETAILED REFILLS (Date, Time, Tank) + FIXES

let consumptionChart, levelChart;
let currentData = [];
let autoRefreshInterval = null;

// CONFIG
const CRITICAL_LEVEL = 50;
const REFILL_THRESHOLD = 20; 
const NOISE_THRESHOLD = 0.5; 
const CONSUMPTION_PER_HOUR = 7; 

const urlParams = new URLSearchParams(window.location.search);
const dgType = urlParams.get('dg') || 'dg1';

const titles = { 
    'dg1': 'DG-1 Consumption', 
    'dg2': 'DG-2 Consumption', 
    'dg3': 'DG-3 Consumption', 
    'total': 'Total Consumption' 
};
document.getElementById('page-title').textContent = titles[dgType] || titles['dg1'];

function formatNumber(num) {
    if (num === null || num === undefined || isNaN(num)) return '--';
    return parseFloat(Number(num).toFixed(2)); 
}

function setDateRange(range) {
    const end = new Date();
    const start = new Date();
    if (range === 'yesterday') {
        start.setDate(start.getDate() - 1);
        end.setDate(end.getDate() - 1);
    } else if (range === 'week') {
        start.setDate(start.getDate() - 6);
    } else if (range === 'month') {
        start.setDate(start.getDate() - 29);
    }
    document.getElementById('start-date').value = start.toISOString().split('T')[0];
    document.getElementById('end-date').value = end.toISOString().split('T')[0];
}

setDateRange('today'); 
document.getElementById('quick-select').value = 'today';
document.getElementById('quick-select').addEventListener('change', function() {
  if (this.value !== 'custom') setDateRange(this.value);
});

function setupAutoRefresh() {
  const startDate = document.getElementById('start-date').value;
  const endDate = document.getElementById('end-date').value;
  const today = new Date().toISOString().split('T')[0];
  if (autoRefreshInterval) { clearInterval(autoRefreshInterval); autoRefreshInterval = null; }
  if (startDate === today && endDate === today) {
    autoRefreshInterval = setInterval(() => { loadData(true); }, 30000);
  }
}

function generateZeroDataForTimeline(level = 0) {
    const now = new Date();
    const data = [];
    let currentHour = 7; 
    let currentMinute = 0;
    let endHour = now.getHours();
    let endMinute = now.getMinutes();
    level = parseFloat(level) || 0;

    while (currentHour < endHour || (currentHour === endHour && currentMinute <= endMinute)) {
        const d = new Date();
        d.setHours(currentHour, currentMinute, 0, 0);
        
        // Create structure that matches API response for Total or Single
        let record = {
            timestamp: d.toISOString(),
            level: level, // Flat level for single DG logic
            cleanLevel: level, 
            cleanConsumption: 0,
            date: d.toISOString().split('T')[0] 
        };

        // For total view, we need nested structure to prevent errors
        if (dgType === 'total') {
            record.total = { level: level };
            record.dg1 = { level: level/3 }; // Dummy split for internal logic
            record.dg2 = { level: level/3 };
            record.dg3 = { level: level/3 };
        } else {
            record[dgType] = { level: level };
        }
        
        data.push(record);

        currentMinute += 30;
        if (currentMinute >= 60) { currentMinute = 0; currentHour++; }
    }
    return data;
}

async function loadData(silent = false) {
  const startDate = document.getElementById('start-date').value;
  const endDate = document.getElementById('end-date').value;
  
  if (!silent) { 
      document.getElementById('loading').style.display = 'block'; 
      document.getElementById('empty-state').style.display = 'none'; 
  }

  try {
    const query = `startDate=${startDate}&endDate=${endDate}`;
    const url = (dgType === 'total') ? `/api/consumption?${query}` : `/api/consumption?dg=${dgType}&${query}`;
    const response = await fetch(url);
    const result = await response.json();

    let displayData = result.data || [];
    const isToday = (startDate === new Date().toISOString().split('T')[0]);

    if (displayData.length === 0 && isToday) {
        console.log("No history today. Fetching live level...");
        try {
            const liveRes = await fetch('/api/data');
            const liveJson = await liveRes.json();
            let currentLevel = 0;
            const rawVal = liveJson[dgType];
            if (typeof rawVal === 'object' && rawVal !== null) {
                currentLevel = rawVal.level || 0; 
            } else {
                currentLevel = rawVal || 0; 
            }
            console.log(`Live Level for ${dgType}: ${currentLevel}`);
            displayData = generateZeroDataForTimeline(currentLevel);
        } catch (e) {
            console.error("Live fetch failed", e);
            displayData = generateZeroDataForTimeline(0);
        }
    } 
    else if (displayData.length === 0) {
        showEmptyState();
        return;
    }

    processData(displayData, startDate, endDate);
    document.getElementById('empty-state').style.display = 'none';
    setupAutoRefresh();

  } catch (err) {
    console.error('Error:', err);
    showEmptyState();
  } finally {
    if (!silent) document.getElementById('loading').style.display = 'none';
  }
}

function showEmptyState() {
  document.getElementById('empty-state').style.display = 'block';
  if (consumptionChart) consumptionChart.destroy();
  if (levelChart) levelChart.destroy();
  clearStats();
}

function clearStats() {
  document.getElementById('start-level').textContent = '--';
  document.getElementById('end-level').textContent = '--';
  document.getElementById('total-consumption').textContent = '--';
  document.getElementById('running-hours').textContent = '--';
  document.getElementById('avg-consumption').textContent = '--';
  document.getElementById('total-refilled').textContent = '--';
  document.getElementById('refill-details').innerHTML = '';
  document.getElementById('refill-prediction').textContent = '--';
}

// ‚úÖ IMPROVED LOGIC: Track Refills per DG even in Total Mode
function processWithNoiseFilter(data, selectedDg) {
  let totalConsumption = 0;
  let totalRefilled = 0;
  let refillEvents = [];
  
  // Trackers for stability
  let stableLevel = null; // For the main chart line
  
  // Specific trackers to detect individual refills in Total mode
  let stableDG1 = null;
  let stableDG2 = null;
  let stableDG3 = null;

  let cleanData = data.map((record) => {
    if(record.cleanLevel !== undefined) return record; 

    // 1. Main Chart Level Logic
    let mainRawLevel = 0;
    if (selectedDg === 'total') {
        mainRawLevel = record.total?.level || 0; 
    } else {
        mainRawLevel = record.level !== undefined ? record.level : (record[selectedDg]?.level || 0);
    }
    
    if (stableLevel === null) stableLevel = mainRawLevel;
    
    // Main consumption (Total drop)
    let mainDiff = mainRawLevel - stableLevel;
    let mainConsumption = 0;

    // 2. Detailed Refill Detection Logic
    if (selectedDg === 'total') {
        // Check EACH DG individually for refills
        const dg1Level = record.dg1?.level || 0;
        const dg2Level = record.dg2?.level || 0;
        const dg3Level = record.dg3?.level || 0;

        if (stableDG1 === null) { stableDG1 = dg1Level; stableDG2 = dg2Level; stableDG3 = dg3Level; }

        // Check DG1
        if ((dg1Level - stableDG1) > REFILL_THRESHOLD) {
            let amt = dg1Level - stableDG1;
            totalRefilled += amt;
            refillEvents.push(createRefillEvent(record.timestamp, 'DG-1', amt));
            stableDG1 = dg1Level;
        } else { stableDG1 = dg1Level; } // Update tracker (simplified for total view stability)

        // Check DG2
        if ((dg2Level - stableDG2) > REFILL_THRESHOLD) {
            let amt = dg2Level - stableDG2;
            totalRefilled += amt;
            refillEvents.push(createRefillEvent(record.timestamp, 'DG-2', amt));
            stableDG2 = dg2Level;
        } else { stableDG2 = dg2Level; }

        // Check DG3
        if ((dg3Level - stableDG3) > REFILL_THRESHOLD) {
            let amt = dg3Level - stableDG3;
            totalRefilled += amt;
            refillEvents.push(createRefillEvent(record.timestamp, 'DG-3', amt));
            stableDG3 = dg3Level;
        } else { stableDG3 = dg3Level; }

    } else {
        // Single DG Mode
        if (mainDiff > REFILL_THRESHOLD) {
            totalRefilled += mainDiff;
            refillEvents.push(createRefillEvent(record.timestamp, selectedDg.toUpperCase(), mainDiff));
            stableLevel = mainRawLevel; // Reset stable
        }
    }

    // 3. Consumption Logic (based on main level)
    // We recalculate mainDiff based on updated stableLevel if it was a single DG refill
    mainDiff = mainRawLevel - stableLevel;
    
    if (mainDiff < -NOISE_THRESHOLD) {
        mainConsumption = Math.abs(mainDiff);
        totalConsumption += mainConsumption;
        stableLevel = mainRawLevel; 
    } else if (selectedDg === 'total' && mainDiff > REFILL_THRESHOLD) {
        // If total jumped significantly (sum of refills), update stable
        stableLevel = mainRawLevel;
    } else if (selectedDg !== 'total' && mainDiff > REFILL_THRESHOLD) {
        stableLevel = mainRawLevel;
    }

    return { 
        ...record, 
        cleanLevel: stableLevel, 
        cleanConsumption: mainConsumption,
        dateStr: record.timestamp.split('T')[0]
    };
  });
  
  return { totalConsumption, totalRefilled, refillEvents, cleanData };
}

function createRefillEvent(timestamp, tankName, amount) {
    const d = new Date(timestamp);
    return {
        timestamp: timestamp,
        amount: amount,
        tank: tankName.replace('DG', 'DG-'), // Ensure formatting
        date: d.toLocaleDateString('en-IN'),
        time: d.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' })
    };
}

function processData(data, startDate, endDate) {
  const startStr = new Date(startDate).toLocaleDateString('en-IN', { day: 'numeric', month: 'short' });
  document.getElementById('date-range').textContent = startStr;

  const { totalConsumption, totalRefilled, refillEvents, cleanData } = processWithNoiseFilter(data, dgType);

  let startLevel = 0;
  let endLevel = 0;
  if (cleanData.length > 0) {
      startLevel = cleanData[0].cleanLevel;
      endLevel = cleanData[cleanData.length - 1].cleanLevel;
  }

  let runningHours = (totalConsumption > 0) ? (totalConsumption / CONSUMPTION_PER_HOUR) : 0;
  const avgConsumptionRate = runningHours > 0 ? (totalConsumption / runningHours) : 0;

  let daysRemaining = '--';
  if (endLevel > CRITICAL_LEVEL) {
      const rate = avgConsumptionRate > 0 ? avgConsumptionRate : CONSUMPTION_PER_HOUR;
      const usableDiesel = endLevel - CRITICAL_LEVEL;
      daysRemaining = ((usableDiesel / rate) / 24).toFixed(1);
      if(avgConsumptionRate === 0) daysRemaining += " (Est)";
  } else {
      daysRemaining = "0.0 (Critical)";
  }

  document.getElementById('start-level').textContent = formatNumber(startLevel);
  document.getElementById('end-level').textContent = formatNumber(endLevel);
  document.getElementById('total-consumption').textContent = formatNumber(totalConsumption);
  document.getElementById('running-hours').textContent = formatNumber(runningHours);
  document.getElementById('avg-consumption').textContent = formatNumber(avgConsumptionRate || CONSUMPTION_PER_HOUR);
  document.getElementById('refill-prediction').textContent = daysRemaining;

  // ‚úÖ REFILL DETAILS DISPLAY
  const totalRefilledEl = document.getElementById('total-refilled');
  const refillDetailsEl = document.getElementById('refill-details');
  const refillCard = document.getElementById('refill-info-card');
  
  refillCard.style.display = 'block'; 
  totalRefilledEl.textContent = formatNumber(totalRefilled);

  if (totalRefilled > 0 && refillEvents.length > 0) {
    let detailsHTML = ``;
    refillEvents.forEach(event => { 
        // Format: Date Time - Tank: Amount
        detailsHTML += `
        <div style="border-bottom:1px solid #eee; padding:4px 0; font-size:0.8rem;">
            üìÖ <b>${event.date} ${event.time}</b><br>
            üõ¢Ô∏è <b style="color:#0052cc">${event.tank}</b>: +${formatNumber(event.amount)} L
        </div>`; 
    });
    refillDetailsEl.innerHTML = detailsHTML;
  } else {
    refillDetailsEl.innerHTML = '<span style="color:var(--text-muted); font-size:0.8rem;">No refills detected.</span>';
  }

  updateCharts(cleanData, startDate, endDate, refillEvents);
}

function updateCharts(cleanData, startDate, endDate, refillEvents) {
  const isMultiDay = (new Date(endDate) - new Date(startDate)) > 0;
  let labels = []; let consumptionData = []; let levelData = []; let pointColors = []; let pointRadiuses = [];
  let tooltipTimes = [];

  if (!isMultiDay) {
    const now = new Date();
    const isToday = (startDate === now.toISOString().split('T')[0]);
    let startHour = 7; let endHour = isToday ? now.getHours() : 20; let currentMinute = now.getMinutes();
    let lastKnownLevel = parseFloat(document.getElementById('start-level').textContent) || 0;

    const dataMap = {};
    cleanData.forEach(d => {
        let h = new Date(d.timestamp).getHours();
        let m = new Date(d.timestamp).getMinutes();
        dataMap[`${h}:${m}`] = d;
    });

    for (let h = startHour; h <= endHour; h++) {
        for (let m of [0, 30]) { 
            if (isToday && h === now.getHours() && m > currentMinute) break;
            let hour12 = (h > 12) ? h - 12 : (h === 0 ? 12 : h);
            let ampm = (h >= 12) ? 'PM' : 'AM';
            let timeStr = `${hour12}:${m.toString().padStart(2,'0')} ${ampm}`;
            labels.push(timeStr);
            tooltipTimes.push(timeStr);

            let timeKey = `${h}:${m}`;
            let record = dataMap[timeKey];
            if(!record) {
                 record = cleanData.find(d => {
                    let dh = new Date(d.timestamp).getHours();
                    let dm = new Date(d.timestamp).getMinutes();
                    return dh === h && Math.abs(dm - m) < 5;
                 });
            }

            if (record) {
                lastKnownLevel = record.cleanLevel; 
                levelData.push(lastKnownLevel);
                consumptionData.push(record.cleanConsumption);
                // Check if ANY refill happened around this time
                let isRefill = refillEvents.some(e => {
                    let ed = new Date(e.timestamp);
                    return ed.getHours() === h && Math.abs(ed.getMinutes() - m) < 5;
                });
                pointColors.push(isRefill ? '#0052cc' : 'rgba(0, 135, 90, 1)');
                pointRadiuses.push(isRefill ? 6 : 0);
            } else {
                levelData.push(lastKnownLevel); 
                consumptionData.push(0);
                pointColors.push('rgba(0, 135, 90, 1)');
                pointRadiuses.push(0);
            }
        }
    }
    document.getElementById('consumption-chart-title').textContent = 'üìà Diesel Consumption (Filtered)';
    document.getElementById('level-chart-title').textContent = 'üìâ Diesel Level (Noise Reduced)';
  } else {
    cleanData.forEach(d => {
         labels.push(d.date); 
         const t = new Date(d.timestamp);
         tooltipTimes.push(t.toLocaleString('en-IN', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' }));
         levelData.push(d.cleanLevel);
         consumptionData.push(d.cleanConsumption);
         pointColors.push('rgba(0, 135, 90, 1)');
         pointRadiuses.push(3);
    });
  }

  if (consumptionChart) consumptionChart.destroy();
  consumptionChart = new Chart(document.getElementById('consumptionChart'), {
    type: 'bar',
    data: { labels: labels, datasets: [{ label: 'Consumption (L)', data: consumptionData, backgroundColor: 'rgba(222, 53, 11, 0.8)', borderColor: 'rgba(222, 53, 11, 1)', borderWidth: 1 }] },
    options: { 
        responsive: true, maintainAspectRatio: false, 
        plugins: { tooltip: { callbacks: { title: ctx => `Time: ${tooltipTimes[ctx[0].dataIndex]}`, label: ctx => `Consumption: ${ctx.raw} L` } } },
        scales: { y: { beginAtZero: true }, x: { ticks: { maxRotation: 45, minRotation: 45 } } } 
    }
  });

  if (levelChart) levelChart.destroy();
  levelChart = new Chart(document.getElementById('levelChart'), {
    type: 'line',
    data: { labels: labels, datasets: [{ label: 'Diesel Level (L)', data: levelData, borderColor: 'rgba(0, 135, 90, 1)', backgroundColor: 'rgba(0, 135, 90, 0.1)', borderWidth: 3, fill: true, tension: 0, spanGaps: true, pointBackgroundColor: pointColors, pointRadius: pointRadiuses }] },
    options: { 
        responsive: true, maintainAspectRatio: false, 
        plugins: { tooltip: { callbacks: { 
            title: ctx => `Time: ${tooltipTimes[ctx[0].dataIndex]}`, 
            label: ctx => { 
                let idx = ctx.dataIndex; 
                if (pointColors[idx] === '#0052cc') {
                    // Find specific refill for tooltip
                    // (Simplification: just show Refill Detected)
                    return `‚õΩ Refill Detected! Level: ${ctx.raw}L`; 
                }
                return `Level: ${ctx.raw}L`; 
            } 
        } } }, 
        scales: { y: { beginAtZero: false }, x: { ticks: { maxRotation: 45, minRotation: 45 } } } 
    }
  });
}

function exportAllData() {
  const startDate = document.getElementById('start-date').value;
  const endDate = document.getElementById('end-date').value;
  window.location.href = `/api/export/all?startDate=${startDate}&endDate=${endDate}`;
}

loadData();
window.addEventListener('beforeunload', () => { if (autoRefreshInterval) clearInterval(autoRefreshInterval); });
</script>
</body>
</html>