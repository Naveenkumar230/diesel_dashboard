<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DG Consumption Details</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
  :root {
    --primary: #0052cc; --success: #00875a; --warning: #ffab00; --danger: #de350b;
    --bg-primary: #ffffff; --bg-secondary: #f4f5f7; --bg-tertiary: #ffffff;
    --text-primary: #172b4d; --text-secondary: #42526e; --text-muted: #6b778c;
    --border: #dfe1e6;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: var(--bg-primary); font-family: 'Segoe UI', Tahoma, sans-serif; color: var(--text-primary); min-height: 100vh; padding: 15px; }
  .container { max-width: 1600px; margin: 0 auto; }
  .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 20px; background: var(--bg-secondary); border-radius: 12px; border: 1px solid var(--border); flex-wrap: wrap; gap: 15px; }
  .header-left h1 { font-size: 1.8rem; background: linear-gradient(90deg, #0052cc, #0065ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 5px; }
  .header-left .subtitle { font-size: 0.9rem; color: var(--text-muted); }
  .header-right { display: flex; gap: 10px; flex-wrap: wrap; }
  .btn { padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; font-weight: 600; transition: all 0.3s; text-decoration: none; display: inline-block; font-size: 0.95rem; }
  .btn-primary { background: var(--primary); color: white; }
  .btn-primary:hover { background: #0041a3; transform: translateY(-2px); }
  .btn-success { background: var(--success); color: white; }
  .btn-success:hover { background: #006644; transform: translateY(-2px); }
  .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); }
  .btn-secondary:hover { background: #dfe1e6; }
  .filters { background: var(--bg-secondary); border: 1px solid var(--border); padding: 20px; border-radius: 12px; margin-bottom: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
  .filter-group { display: flex; flex-direction: column; gap: 8px; }
  label { font-size: 0.9rem; color: var(--text-muted); font-weight: 600; }
  input, select { padding: 10px; border-radius: 6px; border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary); font-size: 0.95rem; }
  .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 25px; }
  .stat-card { background: var(--bg-tertiary); border: 1px solid var(--border); padding: 20px; border-radius: 12px; text-align: center; border-top: 4px solid var(--primary); }
  .stat-label { font-size: 0.85rem; color: var(--text-muted); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-value { font-size: 2.2rem; font-weight: 800; margin-bottom: 5px; color: var(--text-primary); }
  .stat-unit { font-size: 0.85rem; color: var(--text-muted); }
  .chart-section { background: var(--bg-secondary); border: 1px solid var(--border); padding: 25px; border-radius: 12px; margin-bottom: 20px; }
  .chart-title { font-size: 1.3rem; font-weight: 700; margin-bottom: 20px; color: var(--text-primary); border-left: 4px solid var(--primary); padding-left: 15px; }
  .chart-container { position: relative; height: 400px; }
  .running-hours-section { background: var(--bg-secondary); border: 1px solid var(--border); padding: 25px; border-radius: 12px; margin-bottom: 20px; }
  .timeline { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
  .timeline-item { display: flex; align-items: center; gap: 15px; padding: 15px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; border-left: 4px solid var(--success); }
  .timeline-item.stopped { border-left-color: var(--danger); }
  .timeline-time { font-weight: 700; min-width: 150px; font-size: 0.95rem; color: var(--text-primary); }
  .timeline-status { padding: 5px 12px; border-radius: 12px; font-size: 0.8rem; font-weight: 700; text-transform: uppercase; }
  .timeline-status.running { background: var(--success); color: white; }
  .timeline-status.stopped { background: var(--danger); color: white; }
  .timeline-consumption { margin-left: auto; font-weight: 700; color: var(--danger); }
  .loading { text-align: center; padding: 60px; color: var(--text-muted); font-size: 1.2rem; }
  .empty-state { text-align: center; padding: 60px; color: var(--text-muted); background: var(--bg-secondary); border-radius: 12px; }
  .empty-state-icon { font-size: 4rem; margin-bottom: 20px; opacity: 0.5; }

  @media (max-width: 768px) {
    .header { flex-direction: column; align-items: flex-start; }
    .header-right { width: 100%; flex-direction: column; }
    .btn { width: 100%; text-align: center; }
    .chart-container { height: 300px; }
    .timeline-item { flex-direction: column; align-items: flex-start; }
    .timeline-consumption { margin-left: 0; }
  }
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1 id="page-title">DG Consumption Details</h1>
        <div class="subtitle" id="date-range">Loading...</div>
      </div>
      <div class="header-right">
        <button class="btn btn-success" onclick="exportAllData()">üì• Download All Data</button>
        <a href="/" class="btn btn-secondary">‚Üê Back to Dashboard</a>
      </div>
    </div>

    <div class="filters">
      <div class="filter-group">
        <label>From Date</label>
        <input type="date" id="start-date" />
      </div>
      <div class="filter-group">
        <label>To Date</label>
        <input type="date" id="end-date" />
      </div>
      <div class="filter-group">
        <label>Quick Select</label>
        <select id="quick-select">
          <option value="today" selected>Today</option>
          <option value="yesterday">Yesterday</option>
          <option value="week">Last 7 Days</option>
          <option value="month">Last 30 Days</option>
          <option value="custom">Custom Range</option>
        </select>
      </div>
      <div class="filter-group" style="justify-content: flex-end;">
        <label>&nbsp;</label>
        <button class="btn btn-primary" onclick="loadData()">Apply Filter</button>
      </div>
    </div>

    <div class="stats-grid">
      <div class="stat-card"><div class="stat-label">Start Level</div><div class="stat-value" id="start-level">--</div><div class="stat-unit">Liters</div></div>
      <div class="stat-card"><div class="stat-label">End Level</div><div class="stat-value" id="end-level">--</div><div class="stat-unit">Liters</div></div>
      <div class="stat-card" style="border-top-color: var(--danger);"><div class="stat-label">Total Consumption</div><div class="stat-value" id="total-consumption" style="color: var(--danger);">--</div><div class="stat-unit">Liters</div></div>
      <div class="stat-card" style="border-top-color: var(--success);"><div class="stat-label">Total Running Hours</div><div class="stat-value" id="running-hours" style="color: var(--success);">--</div><div class="stat-unit">Hours</div></div>
      <div class="stat-card" style="border-top-color: var(--warning);"><div class="stat-label">Avg Consumption</div><div class="stat-value" id="avg-consumption" style="color: var(--warning);">--</div><div class="stat-unit">L/Hour</div></div>
      <div class="stat-card" id="refill-card" style="display: none;"><div class="stat-label">Refill Prediction</div><div class="stat-value" id="refill-prediction" style="color: var(--primary);">--</div><div class="stat-unit">Days until 50L</div></div>
    </div>

    <div class="chart-section">
      <div class="chart-title" id="consumption-chart-title">üìà Hourly Diesel Consumption</div>
      <div class="chart-container">
        <canvas id="consumptionChart"></canvas>
      </div>
    </div>

    <div class="chart-section">
      <div class="chart-title" id="level-chart-title">üìâ Diesel Level Over Time</div>
      <div class="chart-container">
        <canvas id="levelChart"></canvas>
      </div>
    </div>

    <div class="running-hours-section">
      <div class="chart-title">‚è±Ô∏è Running Timeline</div>
      <div id="timeline-container"></div>
    </div>

    <div id="loading" class="loading" style="display:none;">‚è≥ Loading data...</div>
    <div id="empty-state" class="empty-state" style="display:none;">
      <div class="empty-state-icon">üì≠</div>
      <h2>No Data Available</h2>
      <p>No consumption data found for the selected date range.</p>
    </div>
  </div>

  <script>
    let consumptionChart, levelChart;
    let currentData = [];
    const CRITICAL_LEVEL = 50;

    const urlParams = new URLSearchParams(window.location.search);
    const dgType = urlParams.get('dg') || 'dg1';

    const titles = { 'dg1': 'DG-1 Consumption', 'dg2': 'DG-2 Consumption', 'dg3': 'DG-3 Consumption', 'total': 'Total Consumption' };
    document.getElementById('page-title').textContent = titles[dgType] || titles['dg1'];

    if (dgType === 'total') document.getElementById('refill-card').style.display = 'block';

    function setDateRange(range) {
        const end = new Date();
        const start = new Date();
        
        if (range === 'yesterday') {
            start.setDate(start.getDate() - 1);
            end.setDate(end.getDate() - 1);
        } else if (range === 'week') {
            start.setDate(start.getDate() - 6);
        } else if (range === 'month') {
            start.setDate(start.getDate() - 29);
        }
        
        document.getElementById('start-date').value = start.toISOString().split('T')[0];
        document.getElementById('end-date').value = end.toISOString().split('T')[0];
    }

    // DEFAULT IS TODAY
    setDateRange('today'); 
    document.getElementById('quick-select').value = 'today';

    document.getElementById('quick-select').addEventListener('change', function() {
      if (this.value !== 'custom') setDateRange(this.value);
    });

    async function loadData() {
      const startDate = document.getElementById('start-date').value;
      const endDate = document.getElementById('end-date').value;
      if (!startDate || !endDate) { alert('Please select a start and end date'); return; }
      
      document.getElementById('loading').style.display = 'block';
      document.getElementById('empty-state').style.display = 'none';

      try {
        const query = `startDate=${startDate}&endDate=${endDate}`;
        const url = (dgType === 'total') ? `/api/consumption?${query}` : `/api/consumption?dg=${dgType}&${query}`;
        const response = await fetch(url);
        const result = await response.json();

        if (result.success && result.data.length > 0) {
          currentData = result.data;
          processData(result.data, startDate, endDate);
          document.getElementById('empty-state').style.display = 'none';
        } else {
          showEmptyState();
        }
      } catch (err) {
        console.error('Error loading data:', err);
        showEmptyState();
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }

    function showEmptyState() {
      document.getElementById('empty-state').style.display = 'block';
      if (consumptionChart) consumptionChart.destroy();
      if (levelChart) levelChart.destroy();
      clearStats();
      document.getElementById('timeline-container').innerHTML = '<p style="text-align:center; color: var(--text-muted); padding: 20px;">No timeline data available</p>';
    }

    function clearStats() {
      document.getElementById('start-level').textContent = '--';
      document.getElementById('end-level').textContent = '--';
      document.getElementById('total-consumption').textContent = '--';
      document.getElementById('running-hours').textContent = '--';
      document.getElementById('avg-consumption').textContent = '--';
    }

    function processData(data, startDate, endDate) {
      const isMultiDay = (new Date(endDate) - new Date(startDate)) > 0;

      const startStr = new Date(startDate + 'T00:00:00').toLocaleDateString('en-IN', { day: 'numeric', month: 'long' });
      const endStr = new Date(endDate + 'T00:00:00').toLocaleDateString('en-IN', { day: 'numeric', month: 'long' });
      document.getElementById('date-range').textContent = (startStr === endStr) ? startStr : `From ${startStr} to ${endStr}`;

      let startLevel, endLevel, totalConsumption, runningHours;

      if (dgType === 'total') {
        startLevel = data[0]?.total?.level || 0;
        endLevel = data[data.length - 1]?.total?.level || 0;
        totalConsumption = data.reduce((sum, r) => sum + (r.total?.consumption || 0), 0);
        runningHours = data.filter(r => (r.dg1?.isRunning || r.dg2?.isRunning || r.dg3?.isRunning)).length * 0.5;

        const avgConsumptionRate = runningHours > 0 ? (totalConsumption / runningHours) : 0;
        let daysRemaining = '--';
        if (avgConsumptionRate > 0) {
          const usableDiesel = endLevel - CRITICAL_LEVEL;
          daysRemaining = (usableDiesel > 0) ? ((usableDiesel / avgConsumptionRate) / 24).toFixed(1) : '0.0';
        }
        document.getElementById('refill-prediction').textContent = daysRemaining;

      } else {
        startLevel = data[0]?.level || 0;
        endLevel = data[data.length - 1]?.level || 0;
        totalConsumption = data.reduce((sum, r) => sum + (r.consumption || 0), 0);
        runningHours = data.filter(r => r.isRunning).length * 0.5;
      }
      
      // --- GROUND TRUTH LOGIC: Use actual level drop if more reliable ---
      let levelDrop = startLevel - endLevel;
      if (levelDrop > 0 && totalConsumption < levelDrop * 0.95) { 
          totalConsumption = levelDrop;
      }

      document.getElementById('start-level').textContent = startLevel.toFixed(0);
      document.getElementById('end-level').textContent = endLevel.toFixed(0);
      document.getElementById('total-consumption').textContent = totalConsumption.toFixed(1);
      document.getElementById('running-hours').textContent = runningHours.toFixed(1);
      document.getElementById('avg-consumption').textContent = (runningHours > 0 ? (totalConsumption / runningHours) : 0).toFixed(2);

      updateCharts(data, startDate, endDate);
      updateTimeline(data, startDate, endDate);
    }

    function updateCharts(data, startDate, endDate) {
      const isMultiDay = (new Date(endDate) - new Date(startDate)) > 0;
      const chartTextColor = '#172b4d';
      const chartGridColor = 'rgba(23, 43, 77, 0.1)';

      let labels = [];
      let consumptionData = [];
      let levelDatasets = [];

      if (!isMultiDay) {
        // === SINGLE DAY MODE: PRODUCTION HOURS ONLY (8 AM - 8 PM) ===
        document.getElementById('consumption-chart-title').textContent = 'üìà Diesel Consumption (Production Hours: 8 AM - 8 PM)';
        document.getElementById('level-chart-title').textContent = 'üìâ Diesel Level Over Time (8 AM - 8 PM)';
        
        // STEP 1: Filter data for production hours (8 AM to 8 PM) and sort chronologically
        const sortedData = [...data]
            .filter(record => {
                const hour = record.hour;
                // Include only data from 8:00 AM (hour 8) to 8:00 PM (hour 20)
                return hour >= 8 && hour <= 20;
            })
            .sort((a, b) => {
                const timeA = a.hour * 60 + a.minute;
                const timeB = b.hour * 60 + b.minute;
                return timeA - timeB;
            });

        // STEP 2: Build arrays from filtered production hours data
        const levelData = [];
        let previousLevel = null;
        
        // If no data in production hours, show empty state
        if (sortedData.length === 0) {
            labels.push('8:00 AM', '12:00 PM', '4:00 PM', '8:00 PM');
            consumptionData = [0, 0, 0, 0];
            levelData.push(0, 0, 0, 0);
        } else {
            sortedData.forEach((record, index) => {
                const hour = record.hour;
                const minute = record.minute;
                
                // Create readable time label from actual timestamp
                let hourStr = hour > 12 ? hour - 12 : (hour === 0 ? 12 : hour);
                let ampm = hour >= 12 ? 'PM' : 'AM';
                let minuteStr = minute.toString().padStart(2, '0');
                const timeLabel = `${hourStr}:${minuteStr} ${ampm}`;
                
                // Get current level
                let currentLevel;
                if (dgType === 'total') {
                    currentLevel = record.total?.level || 0;
                } else {
                    currentLevel = record.level || 0;
                }
                
                // Calculate consumption for this interval
                let intervalConsumption = 0;
                if (previousLevel !== null && previousLevel > currentLevel) {
                    intervalConsumption = previousLevel - currentLevel;
                }
                
                // Add to arrays
                labels.push(timeLabel);
                consumptionData.push(intervalConsumption);
                levelData.push(currentLevel);
                
                previousLevel = currentLevel;
            });
        }

        // STEP 3: Create Level Dataset
        levelDatasets = [{
            label: (dgType === 'total' ? 'Total' : dgType.toUpperCase()) + ' Level (L)',
            data: levelData,
            borderColor: 'rgba(0, 135, 90, 1)',
            backgroundColor: 'rgba(0, 135, 90, 0.1)',
            borderWidth: 3, 
            fill: true, 
            tension: 0.4, 
            spanGaps: false,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: 'rgba(0, 135, 90, 1)',
            pointBorderColor: '#fff',
            pointBorderWidth: 2
        }];

      } else {
        // === MULTI-DAY MODE: DATE-WISE AGGREGATION ===
        document.getElementById('consumption-chart-title').textContent = 'üìà Daily Consumption Trend';
        document.getElementById('level-chart-title').textContent = 'üìâ Daily End Level';
        
        // Group data by date
        const dateGroups = {};
        
        data.forEach(record => {
            const dateKey = record.date;
            if (!dateGroups[dateKey]) {
                dateGroups[dateKey] = [];
            }
            dateGroups[dateKey].push(record);
        });

        // Process each date
        const sortedDates = Object.keys(dateGroups).sort();
        
        sortedDates.forEach(dateKey => {
            const dayRecords = dateGroups[dateKey];
            
            // Sort by time within the day
            dayRecords.sort((a, b) => {
                const timeA = a.hour * 60 + a.minute;
                const timeB = b.hour * 60 + b.minute;
                return timeA - timeB;
            });

            if (dayRecords.length === 0) return;

            // Get first and last level for the day
            const getLevel = (r) => dgType === 'total' ? (r.total?.level || 0) : (r.level || 0);
            
            const firstLevel = getLevel(dayRecords[0]);
            const lastLevel = getLevel(dayRecords[dayRecords.length - 1]);
            
            // Calculate actual consumption for the day (ground truth)
            const dailyConsumption = Math.max(0, firstLevel - lastLevel);
            
            // Create label
            const dateLabel = new Date(dateKey).toLocaleDateString('en-IN', { 
                day: '2-digit', 
                month: 'short' 
            });
            
            labels.push(dateLabel);
            consumptionData.push(dailyConsumption);
        });

        // Prepare level datasets for multi-day
        const levelDataValues = sortedDates.map(dateKey => {
            const dayRecords = dateGroups[dateKey];
            if (dayRecords.length === 0) return null;
            
            const getLevel = (r) => dgType === 'total' ? (r.total?.level || 0) : (r.level || 0);
            return getLevel(dayRecords[dayRecords.length - 1]); // End of day level
        });

        levelDatasets = [{
            label: (dgType === 'total' ? 'Total' : dgType.toUpperCase()) + ' End Level (L)',
            data: levelDataValues,
            borderColor: 'rgba(0, 135, 90, 1)',
            backgroundColor: 'rgba(0, 135, 90, 0.1)',
            borderWidth: 3,
            fill: false, 
            tension: 0.4, 
            spanGaps: false,
            pointRadius: 5,
            pointHoverRadius: 7,
            pointBackgroundColor: 'rgba(0, 135, 90, 1)',
            pointBorderColor: '#fff',
            pointBorderWidth: 2
        }];
      }

      // === RENDER CONSUMPTION CHART ===
      if (consumptionChart) consumptionChart.destroy();
      consumptionChart = new Chart(document.getElementById('consumptionChart'), {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Consumption (L)',
            data: consumptionData,
            backgroundColor: 'rgba(222, 53, 11, 0.8)',
            borderColor: 'rgba(222, 53, 11, 1)',
            borderWidth: 1,
            borderRadius: 4
          }]
        },
        options: {
          responsive: true, 
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              labels: { color: chartTextColor, font: { size: 12, weight: 'bold' } }
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: '#ddd',
              borderWidth: 1,
              padding: 12,
              displayColors: true,
              callbacks: {
                label: function(context) {
                  return `Consumed: ${context.parsed.y.toFixed(2)} L`;
                }
              }
            }
          },
          scales: { 
            y: { 
              beginAtZero: true,
              ticks: { color: chartTextColor },
              grid: { color: chartGridColor },
              title: { display: true, text: 'Consumption (Liters)', color: chartTextColor, font: { weight: 'bold' } }
            }, 
            x: { 
              ticks: { color: chartTextColor, maxRotation: 45, minRotation: 45 }, 
              grid: { display: false }
            } 
          }
        }
      });

      // === RENDER LEVEL CHART ===
      if (levelChart) levelChart.destroy();
      levelChart = new Chart(document.getElementById('levelChart'), {
        type: 'line',
        data: { 
          labels: labels, 
          datasets: levelDatasets 
        },
        options: {
          responsive: true, 
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              labels: { color: chartTextColor, font: { size: 12, weight: 'bold' } }
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: '#ddd',
              borderWidth: 1,
              padding: 12,
              displayColors: true,
              callbacks: {
                label: function(context) {
                  return `Level: ${context.parsed.y.toFixed(1)} L`;
                }
              }
            }
          },
          scales: { 
            y: { 
              beginAtZero: false,
              ticks: { color: chartTextColor },
              grid: { color: chartGridColor },
              title: { display: true, text: 'Diesel Level (Liters)', color: chartTextColor, font: { weight: 'bold' } }
            }, 
            x: { 
              ticks: { color: chartTextColor, maxRotation: 45, minRotation: 45 }, 
              grid: { color: chartGridColor }
            } 
          }
        }
      });
    }

    function updateTimeline(data, startDate, endDate) {
      const isMultiDay = (new Date(endDate) - new Date(startDate)) > 0;
      const container = document.getElementById('timeline-container');
      container.innerHTML = '';
      
      if (data.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-muted); padding: 20px;">No timeline data available</p>';
        return;
      }
      
      // Sort data chronologically and take last 50 entries
      const sortedData = [...data].sort((a, b) => {
        const timeA = new Date(a.timestamp).getTime();
        const timeB = new Date(b.timestamp).getTime();
        return timeA - timeB;
      });
      
      const sliced = sortedData.slice(-50).reverse(); // Most recent first
      
      sliced.forEach(record => {
        let timeStr;
        const dateObj = new Date(record.timestamp);
        
        if (isMultiDay) {
            timeStr = dateObj.toLocaleDateString('en-IN', {day:'2-digit', month:'short'}) + ' ' + dateObj.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
        } else {
            timeStr = dateObj.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
        }

        let isRunning, consumption;
        if (dgType === 'total') {
          isRunning = record.dg1?.isRunning || record.dg2?.isRunning || record.dg3?.isRunning;
          consumption = record.total?.consumption || 0;
        } else {
          isRunning = record.isRunning;
          consumption = record.consumption || 0;
        }
        
        const item = document.createElement('div');
        item.className = `timeline-item ${isRunning ? '' : 'stopped'}`;
        item.innerHTML = `
          <div class="timeline-time">${timeStr}</div>
          <div class="timeline-status ${isRunning ? 'running' : 'stopped'}">${isRunning ? 'üü¢ Running' : 'üî¥ Stopped'}</div>
          <div class="timeline-consumption">${consumption.toFixed(1)} L consumed</div>
        `;
        container.appendChild(item);
      });
    }

    function exportAllData() {
      const startDate = document.getElementById('start-date').value;
      const endDate = document.getElementById('end-date').value;
      if (!startDate || !endDate) { alert('Please select a date range'); return; }
      window.location.href = `/api/export/all?startDate=${startDate}&endDate=${endDate}`;
    }

    // Load data on page load
    loadData();
  </script>
</body>
</html>