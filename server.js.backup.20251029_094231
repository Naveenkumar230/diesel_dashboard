require('dotenv').config();
const ModbusRTU = require("modbus-serial");
const express = require('express');
const path = require('path');
const mongoose = require('mongoose');
const cors = require('cors');
const nodemailer = require('nodemailer');
const compression = require('compression');

// ============================================
// MONGODB CONNECTION WITH IMPROVED ERROR HANDLING
// ============================================
const MONGODB_URI = process.env.MONGODB_URI || "mongodb://localhost:27017/dieselDB";

const mongooseOptions = {
    serverSelectionTimeoutMS: 10000,
    socketTimeoutMS: 45000,
    connectTimeoutMS: 10000,
    maxPoolSize: 10,
    minPoolSize: 2,
    retryWrites: true,
    retryReads: true,
    bufferCommands: false,
    autoIndex: true
};

let isMongoConnected = false;
let connectionAttempts = 0;
const MAX_RETRY_ATTEMPTS = 3;

async function connectMongoDB() {
    connectionAttempts++;
    
    try {
        console.log(`\nüîÑ MongoDB connection attempt ${connectionAttempts}/${MAX_RETRY_ATTEMPTS}...`);
        await mongoose.connect(MONGODB_URI, mongooseOptions);
        console.log('‚úÖ MongoDB Connected Successfully');
        console.log(`   Database: ${mongoose.connection.name}`);
        console.log(`   Host: ${mongoose.connection.host}`);
        isMongoConnected = true;
        connectionAttempts = 0;
    } catch (err) {
        console.error('‚ùå MongoDB Connection Error:', err.message);
        
        if (err.message.includes('IP') || err.message.includes('whitelist')) {
            console.log('\nüí° IP Whitelist Issue:');
            console.log('   1. Go to: https://cloud.mongodb.com');
            console.log('   2. Navigate to Network Access');
            console.log('   3. Add your IP or allow all (0.0.0.0/0)');
        } else if (err.message.includes('SSL') || err.message.includes('TLS')) {
            console.log('\nüí° SSL/TLS Issue:');
            console.log('   Add to .env: &tls=true&tlsAllowInvalidCertificates=true');
        } else if (err.message.includes('authentication')) {
            console.log('\nüí° Authentication Issue:');
            console.log('   Verify username/password in MONGODB_URI');
        }
        
        if (connectionAttempts < MAX_RETRY_ATTEMPTS) {
            console.log(`\n‚è≥ Retrying in 5 seconds...`);
            setTimeout(connectMongoDB, 5000);
        } else {
            console.log('\n‚ö†Ô∏è  MongoDB unavailable after multiple attempts');
            console.log('‚ö†Ô∏è  System continues WITHOUT database (data not persistent)');
            console.log('üí° Consider installing local MongoDB: sudo apt-get install mongodb\n');
        }
        
        isMongoConnected = false;
    }
}

mongoose.connection.on('connected', () => {
    console.log('‚úÖ MongoDB connection established');
    isMongoConnected = true;
});

mongoose.connection.on('disconnected', () => {
    console.log('‚ö†Ô∏è  MongoDB disconnected - attempting reconnect...');
    isMongoConnected = false;
    setTimeout(connectMongoDB, 5000);
});

mongoose.connection.on('error', (err) => {
    console.error('‚ùå MongoDB error:', err.message);
    isMongoConnected = false;
});

connectMongoDB();

// ============================================
// EMAIL CONFIGURATION
// ============================================
let emailTransporter = null;
let emailEnabled = false;

try {
    if (process.env.EMAIL_USER && process.env.EMAIL_APP_PASSWORD) {
        emailTransporter = nodemailer.createTransport({
            service: 'gmail',
            auth: {
                user: process.env.EMAIL_USER,
                pass: process.env.EMAIL_APP_PASSWORD
            }
        });
        emailEnabled = true;
        console.log('‚úÖ Email alerts enabled');
    } else {
        console.log('‚ö†Ô∏è  Email alerts disabled (credentials not configured)');
    }
} catch (error) {
    console.error('‚ùå Email configuration error:', error.message);
    emailEnabled = false;
}

const alertState = {
    lastAlertTime: {},
    currentAlerts: new Set()
};

const ALERT_COOLDOWN = parseInt(process.env.ALERT_COOLDOWN) || 1800000;
const CRITICAL_LEVEL = parseInt(process.env.CRITICAL_DIESEL_LEVEL) || 50;
const WARNING_LEVEL = parseInt(process.env.WARNING_DIESEL_LEVEL) || 30;
const ALERT_RECIPIENTS = process.env.ALERT_RECIPIENTS || '';

// ============================================
// OPTIMIZED MONGOOSE SCHEMA - HOURLY LOGGING
// ============================================
const DieselReadingSchema = new mongoose.Schema({
    timestamp: { type: Date, default: Date.now, index: true },
    dg1: { type: Number, required: true },
    dg2: { type: Number, required: true },
    dg3: { type: Number, required: true },
    total: { type: Number, required: true },
    dg1_change: { type: Number, default: 0 },
    dg2_change: { type: Number, default: 0 },
    dg3_change: { type: Number, default: 0 },
    hour: { type: Number, index: true }, // Hour of day (0-23)
    date: { type: String, index: true }  // Date string for quick filtering (YYYY-MM-DD)
});

// Compound index for faster queries
DieselReadingSchema.index({ date: 1, hour: 1 });
DieselReadingSchema.index({ timestamp: -1 });

const DieselReading = mongoose.model('DieselReading', DieselReadingSchema);

// Cache for recent data to reduce database queries
let dataCache = {
    hourly: null,
    daily: null,
    lastUpdate: null,
    cacheDuration: 5 * 60 * 1000 // 5 minutes cache
};

// ============================================
// EMAIL TEMPLATES
// ============================================
function getEmailTemplate(alertType, data) {
    const timestamp = new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
    const dashboardUrl = `http://${process.env.PI_IP_ADDRESS || '192.168.30.156'}:${process.env.PORT || 3000}`;
    
    const templates = {
        critical: {
            subject: 'üö® CRITICAL: Diesel Level Alert - Immediate Action Required',
            html: `
<!DOCTYPE html>
<html>
<head><style>
body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 0; padding: 0; background: #f5f5f5; }
.container { max-width: 600px; margin: 20px auto; background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
.header { background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%); padding: 40px 24px; text-align: center; color: white; }
.header h1 { margin: 0; font-size: 28px; font-weight: 700; }
.content { padding: 32px 24px; }
.alert-box { background: #fef2f2; border-left: 4px solid #dc2626; padding: 20px; margin: 24px 0; border-radius: 8px; }
.alert-box h2 { color: #991b1b; margin: 0 0 12px 0; font-size: 18px; font-weight: 700; }
.alert-box p { color: #7f1d1d; margin: 0; line-height: 1.6; }
.metric-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin: 24px 0; }
.metric { background: #f9fafb; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #e5e7eb; }
.metric-label { font-size: 12px; color: #6b7280; text-transform: uppercase; font-weight: 600; margin-bottom: 8px; }
.metric-value { font-size: 32px; font-weight: 700; color: #111827; }
.critical { color: #dc2626; }
.button { display: inline-block; background: #2563eb; color: white; padding: 14px 32px; text-decoration: none; border-radius: 8px; font-weight: 600; margin: 24px 0; }
.footer { background: #f9fafb; padding: 24px; text-align: center; font-size: 13px; color: #6b7280; border-top: 1px solid #e5e7eb; }
.timestamp { background: #f3f4f6; padding: 12px; border-radius: 6px; text-align: center; margin: 20px 0; color: #374151; font-size: 14px; }
</style></head>
<body>
<div class="container">
    <div class="header">
        <div style="font-size: 48px; margin-bottom: 12px;">üö®</div>
        <h1>Critical Diesel Alert</h1>
    </div>
    <div class="content">
        <div class="alert-box">
            <h2>‚ö†Ô∏è IMMEDIATE ACTION REQUIRED</h2>
            <p>One or more diesel generators have reached critically low fuel levels (‚â§${CRITICAL_LEVEL}L). Immediate refueling is required to prevent operational disruption.</p>
        </div>
        <div class="metric-grid">
            <div class="metric">
                <div class="metric-label">DG-1 Level</div>
                <div class="metric-value ${data.dg1 <= CRITICAL_LEVEL ? 'critical' : ''}">${data.dg1}L</div>
            </div>
            <div class="metric">
                <div class="metric-label">DG-2 Level</div>
                <div class="metric-value ${data.dg2 <= CRITICAL_LEVEL ? 'critical' : ''}">${data.dg2}L</div>
            </div>
            <div class="metric">
                <div class="metric-label">DG-3 Level</div>
                <div class="metric-value ${data.dg3 <= CRITICAL_LEVEL ? 'critical' : ''}">${data.dg3}L</div>
            </div>
            <div class="metric">
                <div class="metric-label">Total Diesel</div>
                <div class="metric-value">${data.total}L</div>
            </div>
        </div>
        <div class="timestamp">
            <strong>Alert Time:</strong> ${timestamp}
        </div>
        <div style="text-align: center;">
            <a href="${dashboardUrl}" class="button">View Live Dashboard ‚Üí</a>
        </div>
    </div>
    <div class="footer">
        DG Monitoring System - Automated Alert<br>
        Critical Level Threshold: ${CRITICAL_LEVEL}L
    </div>
</div>
</body>
</html>`
        }
    };
    
    return templates[alertType] || templates.critical;
}

async function sendEmailAlert(alertType, data) {
    if (!emailEnabled || !ALERT_RECIPIENTS) return;
    
    const alertKey = `${alertType}_${Math.floor(Date.now() / ALERT_COOLDOWN)}`;
    
    if (alertState.currentAlerts.has(alertKey)) return;
    
    try {
        const template = getEmailTemplate(alertType, data);
        
        await emailTransporter.sendMail({
            from: `"DG Monitoring System" <${process.env.EMAIL_USER}>`,
            to: ALERT_RECIPIENTS,
            subject: template.subject,
            html: template.html
        });
        
        alertState.currentAlerts.add(alertKey);
        console.log(`üìß Alert email sent: ${alertType.toUpperCase()}`);
        
        setTimeout(() => {
            alertState.currentAlerts.delete(alertKey);
        }, ALERT_COOLDOWN);
        
    } catch (error) {
        console.error('‚ùå Email send error:', error.message);
    }
}

function checkDieselLevels(data) {
    // Only send alert when any DG reaches 50L or below
    if (data.dg1 <= 50 || data.dg2 <= 50 || data.dg3 <= 50) {
        sendEmailAlert('critical', data);
    }
}

// ============================================
// PLC SETTINGS
// ============================================
const port = process.env.PLC_PORT || '/dev/ttyUSB0';
const plcSettings = {
    baudRate: parseInt(process.env.PLC_BAUD_RATE) || 9600,
    parity: process.env.PLC_PARITY || 'none',
    dataBits: parseInt(process.env.PLC_DATA_BITS) || 8,
    stopBits: parseInt(process.env.PLC_STOP_BITS) || 1
};
const plcSlaveID = parseInt(process.env.PLC_SLAVE_ID) || 1;

const dgRegisters = {
    dg1: { address: 4104, name: "DG-1" },
    dg2: { address: 4100, name: "DG-2" },
    dg3: { address: 4102, name: "DG-3" }
};

let systemData = {
    dg1: 0,
    dg2: 0,
    dg3: 0,
    total: 0,
    lastUpdate: null
};

let previousReading = null;
let previousDieselData = { dg1: 0, dg2: 0, dg3: 0 };
let lastSavedHour = -1; // Track the last hour data was saved

const client = new ModbusRTU();
const app = express();
const webServerPort = parseInt(process.env.PORT) || 3000;
const piIpAddress = process.env.PI_IP_ADDRESS || '192.168.30.156';

// ============================================
// MIDDLEWARE - OPTIMIZED FOR MOBILE
// ============================================
app.use(compression()); // Enable gzip compression for all responses
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.static(__dirname, {
    maxAge: '1d', // Cache static files for 1 day
    etag: true,
    lastModified: true
}));

// Cache control middleware
app.use((req, res, next) => {
    // Enable browser caching for static assets
    if (req.url.match(/\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$/)) {
        res.setHeader('Cache-Control', 'public, max-age=86400'); // 1 day
    }
    next();
});

// ============================================
// DATA CONVERSION FUNCTIONS
// ============================================
function toSignedInt16(value) {
    if (value > 32767) return value - 65536;
    return value;
}

function isValidReading(value) {
    const signedValue = toSignedInt16(value);
    if (value === 65535 || value === 65534 || signedValue === -1) return false;
    return signedValue >= 0 && signedValue <= 600;
}

function smoothValue(currentValue, previousValue, maxChangePercent = 50) {
    if (previousValue === 0 || previousValue === null) return currentValue;
    const changePercent = Math.abs((currentValue - previousValue) / previousValue * 100);
    if (changePercent > maxChangePercent) {
        console.log(`‚ö†Ô∏è  Smoothing: ${previousValue} -> ${currentValue} (${changePercent.toFixed(1)}% change - keeping previous)`);
        return previousValue;
    }
    return currentValue;
}

async function readSingleRegister(address, name, dataKey) {
    try {
        const data = await client.readHoldingRegisters(address, 1);
        
        if (!data || !data.data || data.data.length < 1) {
            console.error(`${name}: Invalid data received`);
            return systemData[dataKey] || 0;
        }
        
        const rawValue = data.data[0];
        
        if (!isValidReading(rawValue)) {
            console.log(`‚ö†Ô∏è  Invalid reading: ${rawValue} for ${name}`);
            return systemData[dataKey] || 0;
        }
        
        const signedValue = toSignedInt16(rawValue);
        let value = Math.max(0, signedValue);
        
        const previousValue = previousDieselData[dataKey] || 0;
        value = smoothValue(value, previousValue, 30);
        previousDieselData[dataKey] = value;
        
        console.log(`${name} (Addr: ${address}): ${value}L [Raw: ${rawValue}]`);
        
        systemData[dataKey] = value;
        return value;
        
    } catch (e) {
        console.error(`${name} Read Error at address ${address}: ${e.message}`);
        return systemData[dataKey] || 0;
    }
}

async function readAllSystemData() {
    try {
        console.log('‚ïê'.repeat(80));
        console.log(`‚è±Ô∏è  ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}`);
        console.log('‚îÄ'.repeat(80));
        
        console.log('üîã Reading Diesel Levels...');
        await readSingleRegister(dgRegisters.dg1.address, dgRegisters.dg1.name, 'dg1');
        await new Promise(resolve => setTimeout(resolve, 250));
        
        await readSingleRegister(dgRegisters.dg2.address, dgRegisters.dg2.name, 'dg2');
        await new Promise(resolve => setTimeout(resolve, 250));
        
        await readSingleRegister(dgRegisters.dg3.address, dgRegisters.dg3.name, 'dg3');
        await new Promise(resolve => setTimeout(resolve, 250));
        
        systemData.total = (systemData.dg1 || 0) + (systemData.dg2 || 0) + (systemData.dg3 || 0);
        systemData.lastUpdate = new Date().toISOString();
        
        console.log('‚ïê'.repeat(80));
        console.log(`üìä SYSTEM STATUS:`);
        console.log(`   DG-1: ${systemData.dg1}L | DG-2: ${systemData.dg2}L | DG-3: ${systemData.dg3}L | Total: ${systemData.total}L`);
        console.log('‚ïê'.repeat(80));
        console.log('');
        
        checkDieselLevels(systemData);
        await saveToDatabase(systemData);
        
    } catch (e) {
        console.error(`\n‚ùå MODBUS EXCEPTION: ${e.message}`);
        console.error('Reconnecting to PLC...\n');
        client.close();
        setTimeout(connectToPLC, 5000);
    }
}

function calculateChange(current, previous) {
    if (!previous) return 0;
    return current - previous;
}

// ============================================
// OPTIMIZED DATABASE SAVING - HOURLY ONLY
// ============================================
async function saveToDatabase(data) {
    if (mongoose.connection.readyState !== 1) {
        return;
    }
    
    try {
        const now = new Date();
        const currentHour = now.getHours();
        
        // Only save once per hour (at the start of each hour)
        if (currentHour === lastSavedHour) {
            return; // Skip saving if we already saved this hour
        }
        
        const dateString = now.toISOString().split('T')[0]; // YYYY-MM-DD
        
        const changes = {
            dg1_change: calculateChange(data.dg1, previousReading?.dg1),
            dg2_change: calculateChange(data.dg2, previousReading?.dg2),
            dg3_change: calculateChange(data.dg3, previousReading?.dg3)
        };

        const reading = new DieselReading({
            timestamp: now,
            dg1: data.dg1,
            dg2: data.dg2,
            dg3: data.dg3,
            total: data.total,
            hour: currentHour,
            date: dateString,
            ...changes
        });

        await reading.save();
        lastSavedHour = currentHour; // Update the last saved hour
        previousReading = data;
        
        // Clear cache after new data is saved
        dataCache.hourly = null;
        dataCache.daily = null;
        
        console.log(`üíæ Hourly data saved to MongoDB (${currentHour}:00)`);
    } catch (error) {
        console.error('‚ùå MongoDB Save Error:', error.message);
        if (error.name === 'MongoNetworkError') {
            isMongoConnected = false;
            console.log('‚ö†Ô∏è  Lost MongoDB connection - attempting reconnect...');
            setTimeout(connectMongoDB, 5000);
        }
    }
}

function connectToPLC() {
    client.connectRTU(port, plcSettings)
        .then(() => {
            console.log(`\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
            console.log(`‚ïë  DG MONITORING SYSTEM - OPTIMIZED EDITION             ‚ïë`);
            console.log(`‚ïë     PLC CONNECTION SUCCESS                            ‚ïë`);
            console.log(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`);
            console.log(`\nüì° Connection Details:`);
            console.log(`   Port: ${port}`);
            console.log(`   Baud Rate: ${plcSettings.baudRate}`);
            console.log(`   Data Bits: ${plcSettings.dataBits}`);
            console.log(`   Parity: ${plcSettings.parity.toUpperCase()}`);
            console.log(`   Stop Bits: ${plcSettings.stopBits}`);
            console.log(`   Slave ID: ${plcSlaveID}`);
            console.log(`\nüìß Email Alert Configuration:`);
            console.log(`   Status: ${emailEnabled ? 'ENABLED' : 'DISABLED'}`);
            if (emailEnabled) {
                console.log(`   Recipients: ${ALERT_RECIPIENTS}`);
                console.log(`   Critical Level: ${CRITICAL_LEVEL}L`);
                console.log(`   Cooldown Period: ${ALERT_COOLDOWN / 60000} minutes`);
            }
            console.log(`\nüìã Register Mapping:`);
            Object.entries(dgRegisters).forEach(([key, reg]) => {
                console.log(`   ${reg.name.padEnd(10)} ‚Üí Address ${reg.address}`);
            });
            console.log(`\nüíæ Database:`);
            console.log(`   MongoDB: ${mongoose.connection.readyState === 1 ? '‚úì Connected' : '‚úó Disconnected'}`);
            console.log(`   Save Frequency: HOURLY (Optimized)`);
            
            client.setID(plcSlaveID);
            client.setTimeout(3000);
            
            setTimeout(() => {
                console.log(`\n${'‚ïê'.repeat(60)}`);
                console.log(`üöÄ Starting live data monitoring...`);
                console.log(`   Update Interval: 2 seconds`);
                console.log(`   Database Save: Every 1 hour (Optimized)`);
                console.log(`   Data Smoothing: Enabled (30% max change threshold)`);
                console.log(`${'‚ïê'.repeat(60)}\n`);
                readAllSystemData();
                setInterval(readAllSystemData, 2000);
            }, 1000);
        })
        .catch((e) => {
            console.error(`\n${'‚ïê'.repeat(60)}`);
            console.error(`‚ùå PLC CONNECTION FAILED`);
            console.error(`${'‚ïê'.repeat(60)}`);
            console.error(`Port: ${port}`);
            console.error(`Error: ${e.message}`);
            console.error(`\n‚ö†Ô∏è  Troubleshooting:`);
            console.error(`   1. Check if PLC is powered on`);
            console.error(`   2. Verify USB cable connection`);
            console.error(`   3. Confirm port name (ls /dev/ttyUSB*)`);
            console.error(`   4. Check user permissions (sudo usermod -a -G dialout $USER)`);
            console.error(`\nüîÑ Retrying connection in 5 seconds...\n`);
            client.close();
            setTimeout(connectToPLC, 5000);
        });
}

// ============================================
// OPTIMIZED EXPRESS API ENDPOINTS
// ============================================

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

app.get('/dashboard', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Real-time data endpoint - lightweight, no database query
app.get('/api/data', (req, res) => {
    res.json({
        timestamp: systemData.lastUpdate || new Date().toISOString(),
        dg1: systemData.dg1,
        dg2: systemData.dg2,
        dg3: systemData.dg3,
        total: systemData.total
    });
});

// Optimized historical data with caching and pagination
app.get('/api/historical', async (req, res) => {
    try {
        if (mongoose.connection.readyState !== 1) {
            return res.json({
                success: false,
                error: 'Database not connected',
                data: []
            });
        }

        const { timeRange = '24h', fromDate, toDate, limit = 500 } = req.query;

        // Check cache first
        const cacheKey = `${timeRange}_${fromDate}_${toDate}`;
        const now = Date.now();
        if (dataCache.hourly && dataCache.lastUpdate && 
            (now - dataCache.lastUpdate < dataCache.cacheDuration) &&
            dataCache.cacheKey === cacheKey) {
            console.log('üì¶ Serving from cache');
            return res.json(dataCache.hourly);
        }

        let query = {};
        
        if (fromDate && toDate && fromDate !== 'null' && toDate !== 'null') {
            const from = new Date(fromDate);
            const to = new Date(toDate);
            
            if (!isNaN(from.getTime()) && !isNaN(to.getTime())) {
                query.timestamp = { $gte: from, $lte: to };
            }
        } else if (timeRange && timeRange !== 'custom') {
            const now = new Date();
            let startTime;
            
            switch(timeRange) {
                case '1h': 
                    startTime = new Date(now.getTime() - 60 * 60 * 1000); 
                    break;
                case '24h': 
                    startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000); 
                    break;
                case '7d': 
                    startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); 
                    break;
                case '30d': 
                    startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000); 
                    break;
                default: 
                    startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            }
            
            query.timestamp = { $gte: startTime };
        }

        // Optimized query with field selection
        const readings = await DieselReading.find(query)
            .select('timestamp dg1 dg2 dg3 total dg1_change dg2_change dg3_change hour date')
            .sort({ timestamp: -1 })
            .limit(parseInt(limit))
            .lean(); // Use lean() for better performance

        const processedData = readings.map(reading => ({
            timestamp: reading.timestamp,
            dg1: reading.dg1,
            dg2: reading.dg2,
            dg3: reading.dg3,
            total: reading.total,
            dg1_change: reading.dg1_change || 0,
            dg2_change: reading.dg2_change || 0,
            dg3_change: reading.dg3_change || 0
        })).reverse();

        const response = {
            success: true,
            count: processedData.length,
            timeRange: timeRange,
            data: processedData
        };

        // Cache the result
        dataCache.hourly = response;
        dataCache.lastUpdate = now;
        dataCache.cacheKey = cacheKey;

        res.json(response);

    } catch (error) {
        console.error('Historical data error:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            data: []
        });
    }
});

// Optimized export with streaming for large datasets
app.get('/api/export', async (req, res) => {
    try {
        if (mongoose.connection.readyState !== 1) {
            return res.status(503).json({
                success: false,
                error: 'Database not connected'
            });
        }

        const { timeRange = '24h', fromDate, toDate } = req.query;
        
        const now = new Date();
        let query = {};
        
        if (fromDate && toDate && fromDate !== 'null' && toDate !== 'null') {
            const from = new Date(fromDate);
            const to = new Date(toDate);
            
            if (!isNaN(from.getTime()) && !isNaN(to.getTime())) {
                query.timestamp = { $gte: from, $lte: to };
            }
        } else {
            let startTime;
            switch(timeRange) {
                case '1h': 
                    startTime = new Date(now.getTime() - 60 * 60 * 1000); 
                    break;
                case '24h': 
                    startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000); 
                    break;
                case '7d': 
                    startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); 
                    break;
                case '30d': 
                    startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000); 
                    break;
                default: 
                    startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            }
            query.timestamp = { $gte: startTime };
        }

        // Use cursor for memory-efficient streaming
        const cursor = DieselReading.find(query)
            .select('timestamp dg1 dg2 dg3 total dg1_change dg2_change dg3_change')
            .sort({ timestamp: 1 })
            .cursor();

        const filename = `dg_data_${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}.csv`;
        
        res.setHeader('Content-Type', 'text/csv; charset=utf-8');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        
        // Write header
        res.write('Date,Time,DG-1 (L),DG-2 (L),DG-3 (L),Total (L),DG-1 Change,DG-2 Change,DG-3 Change\n');
        
        let recordCount = 0;
        
        // Stream data row by row
        for (let reading = await cursor.next(); reading != null; reading = await cursor.next()) {
            const d = new Date(reading.timestamp);
            const dateStr = `${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getDate()).padStart(2, '0')}/${d.getFullYear()}`;
            let hours = d.getHours();
            const minutes = String(d.getMinutes()).padStart(2, '0');
            const seconds = String(d.getSeconds()).padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;
            const timeStr = `${String(hours).padStart(2, '0')}:${minutes}:${seconds} ${ampm}`;
            
            res.write(`${dateStr},${timeStr},${reading.dg1},${reading.dg2},${reading.dg3},${reading.total},${reading.dg1_change || 0},${reading.dg2_change || 0},${reading.dg3_change || 0}\n`);
            recordCount++;
        }
        
        res.end();
        console.log(`üì• Data exported: ${filename} (${recordCount} records)`);

    } catch (error) {
        console.error('Export error:', error);
        if (!res.headersSent) {
            res.status(500).json({
                success: false,
                error: error.message
            });
        }
    }
});

app.get('/api/health', (req, res) => {
    res.json({
        success: true,
        status: 'running',
        timestamp: new Date().toISOString(),
        mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
        lastDataUpdate: systemData.lastUpdate,
        systemStatus: {
            totalDiesel: systemData.total,
            dg1: systemData.dg1,
            dg2: systemData.dg2,
            dg3: systemData.dg3
        },
        alerts: {
            enabled: emailEnabled,
            criticalLevel: CRITICAL_LEVEL,
            recipients: ALERT_RECIPIENTS,
            cooldown: `${ALERT_COOLDOWN / 60000} minutes`
        },
        plc: {
            port: port,
            baudRate: plcSettings.baudRate,
            slaveId: plcSlaveID
        },
        optimization: {
            dataLogging: 'Hourly',
            cacheEnabled: true,
            compressionEnabled: true
        }
    });
});

// Optimized analytics with aggregation pipeline
app.get('/api/analytics', async (req, res) => {
    try {
        if (mongoose.connection.readyState !== 1) {
            return res.json({
                success: false,
                error: 'Database not connected',
                data: null
            });
        }

        const { period = '24h', fromDate, toDate } = req.query;
        
        let query = {};
        
        if (fromDate && toDate && fromDate !== 'null' && toDate !== 'null') {
            const from = new Date(fromDate);
            const to = new Date(toDate);
            
            if (!isNaN(from.getTime()) && !isNaN(to.getTime())) {
                query.timestamp = { $gte: from, $lte: to };
            }
        } else {
            const now = new Date();
            let startTime;
            
            switch(period) {
                case '1h': startTime = new Date(now.getTime() - 60 * 60 * 1000); break;
                case '24h': startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000); break;
                case '7d': startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); break;
                case '30d': startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000); break;
                default: startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            }
            
            query.timestamp = { $gte: startTime };
        }

        // Use aggregation pipeline for better performance
        const analytics = await DieselReading.aggregate([
            { $match: query },
            { $sort: { timestamp: 1 } },
            {
                $group: {
                    _id: null,
                    firstReading: { $first: '$ROOT' },
                    lastReading: { $last: '$ROOT' },
                    avgDg1: { $avg: '$dg1' },
                    avgDg2: { $avg: '$dg2' },
                    avgDg3: { $avg: '$dg3' },
                    maxDg1: { $max: '$dg1' },
                    maxDg2: { $max: '$dg2' },
                    maxDg3: { $max: '$dg3' },
                    minDg1: { $min: '$dg1' },
                    minDg2: { $min: '$dg2' },
                    minDg3: { $min: '$dg3' },
                    count: { $sum: 1 }
                }
            }
        ]);

        if (!analytics || analytics.length === 0) {
            return res.json({
                success: true,
                message: 'Insufficient data for analysis',
                data: null
            });
        }

        const result = analytics[0];
        const dgs = ['dg1', 'dg2', 'dg3'];
        const analyticsData = {};

        dgs.forEach(dg => {
            const firstValue = result.firstReading[dg];
            const lastValue = result.lastReading[dg];
            const consumption = Math.max(0, firstValue - lastValue);

            analyticsData[dg] = {
                startLevel: firstValue,
                endLevel: lastValue,
                consumption: consumption,
                avgLevel: parseFloat(result[`avg${dg.charAt(0).toUpperCase()}${dg.slice(1)}`].toFixed(1)),
                maxLevel: result[`max${dg.charAt(0).toUpperCase()}${dg.slice(1)}`],
                minLevel: result[`min${dg.charAt(0).toUpperCase()}${dg.slice(1)}`]
            };
        });

        const totalConsumption = analyticsData.dg1.consumption + analyticsData.dg2.consumption + analyticsData.dg3.consumption;

        res.json({
            success: true,
            period: period,
            recordCount: result.count,
            analytics: analyticsData,
            summary: {
                totalConsumption: totalConsumption,
                currentTotal: systemData.total
            }
        });

    } catch (error) {
        console.error('Analytics error:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// ============================================
// ERROR HANDLERS
// ============================================

app.use((req, res) => {
    res.status(404).json({
        success: false,
        error: 'Endpoint not found'
    });
});

app.use((err, req, res, next) => {
    console.error('Server error:', err);
    res.status(500).json({
        success: false,
        error: 'Internal server error'
    });
});

// ============================================
// GRACEFUL SHUTDOWN
// ============================================

process.on('SIGINT', async () => {
    console.log('\n\nüõë Shutting down gracefully...');
    
    try {
        client.close();
        console.log('‚úì PLC connection closed');
        
        await mongoose.connection.close();
        console.log('‚úì MongoDB connection closed');
        
        console.log('‚úì Shutdown complete\n');
        process.exit(0);
    } catch (error) {
        console.error('Error during shutdown:', error);
        process.exit(1);
    }
});

process.on('SIGTERM', async () => {
    console.log('\n\nüõë Received SIGTERM, shutting down...');
    
    try {
        client.close();
        await mongoose.connection.close();
        console.log('‚úì Shutdown complete\n');
        process.exit(0);
    } catch (error) {
        console.error('Error during shutdown:', error);
        process.exit(1);
    }
});

// ============================================
// START WEB SERVER
// ============================================

app.listen(webServerPort, () => {
    console.log(`\n${'‚ïê'.repeat(70)}`);
    console.log(`‚ïë${' '.repeat(68)}‚ïë`);
    console.log(`‚ïë    üöÄ DG MONITORING SYSTEM - OPTIMIZED EDITION üöÄ${' '.repeat(17)}‚ïë`);
    console.log(`‚ïë${' '.repeat(68)}‚ïë`);
    console.log(`${'‚ïê'.repeat(70)}`);
    console.log(`\nüì° WEB SERVER STARTED SUCCESSFULLY`);
    console.log(`${'‚îÄ'.repeat(70)}`);
    console.log(`\nüåê Access Points:`);
    console.log(`   Dashboard:        http://${piIpAddress}:${webServerPort}/`);
    console.log(`   Live Data API:    http://${piIpAddress}:${webServerPort}/api/data`);
    console.log(`   Historical API:   http://${piIpAddress}:${webServerPort}/api/historical`);
    console.log(`   Analytics API:    http://${piIpAddress}:${webServerPort}/api/analytics`);
    console.log(`   Export CSV:       http://${piIpAddress}:${webServerPort}/api/export`);
    console.log(`   Health Check:     http://${piIpAddress}:${webServerPort}/api/health`);
    console.log(`\nüì± Mobile Optimizations:`);
    console.log(`   ‚úì Gzip compression enabled`);
    console.log(`   ‚úì Response caching (5 min)`);
    console.log(`   ‚úì Static asset caching (1 day)`);
    console.log(`   ‚úì Reduced database queries`);
    console.log(`   ‚úì Memory-efficient streaming`);
    console.log(`\nüìä Data Logging:`);
    console.log(`   ‚úì Frequency: HOURLY (Every hour at :00)`);
    console.log(`   ‚úì PLC Reading: Every 2 seconds`);
    console.log(`   ‚úì Database: Saves once per hour`);
    console.log(`   ‚úì Export: Hourly data points`);
    console.log(`\nüîß System Configuration:`);
    console.log(`   Server Port: ${webServerPort}`);
    console.log(`   PLC Port: ${port}`);
    console.log(`   Database: ${mongoose.connection.readyState === 1 ? '‚úì Connected' : '‚è≥ Connecting...'}`);
    console.log(`   Email Alerts: ${emailEnabled ? '‚úì Enabled' : '‚úó Disabled'}`);
    console.log(`\n${'‚ïê'.repeat(70)}\n`);
    
    connectToPLC();
});

// ============================================
// INITIAL STARTUP LOG
// ============================================

console.log(`\n${'‚ïê'.repeat(70)}`);
console.log(`  DG MONITORING SYSTEM v3.0.0 - OPTIMIZED EDITION`);
console.log(`  Starting up...`);
console.log(`${'‚ïê'.repeat(70)}\n`);
console.log(`üìÖ Startup Time: ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}`);
console.log(`üíª Node Version: ${process.version}`);
console.log(`üñ•Ô∏è  Platform: ${process.platform}`);
console.log(`üìÇ Working Directory: ${__dirname}`);
console.log(`\n‚öôÔ∏è  Loading configuration...`);
console.log(`   PORT: ${webServerPort}`);
console.log(`   PLC_PORT: ${port}`);
console.log(`   PLC_BAUD_RATE: ${plcSettings.baudRate}`);
console.log(`   PLC_SLAVE_ID: ${plcSlaveID}`);
console.log(`   PI_IP_ADDRESS: ${piIpAddress}`);
console.log(`   CRITICAL_LEVEL: ${CRITICAL_LEVEL}L`);
console.log(`   ALERT_COOLDOWN: ${ALERT_COOLDOWN / 60000} minutes`);
console.log(`   ALERT_RECIPIENTS: ${ALERT_RECIPIENTS || 'Not configured'}`);
console.log(`   DATA_LOGGING: HOURLY (Optimized)`);
console.log(`\n‚úÖ Configuration loaded successfully`);
console.log(`üîå Initializing web server...\n`);